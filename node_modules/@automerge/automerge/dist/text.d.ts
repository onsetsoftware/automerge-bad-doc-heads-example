import { Value } from "@automerge/automerge-wasm";
export declare class Text {
    elems: Value[];
    str: string | undefined;
    spans: Value[] | undefined;
    constructor(text?: string | string[] | Value[]);
    get length(): number;
    get(index: number): Value | undefined;
    /**
     * Iterates over the text elements character by character, including any
     * inline objects.
     */
    [Symbol.iterator](): {
        next(): {
            done: boolean;
            value: Value;
        } | {
            done: boolean;
            value?: undefined;
        };
    };
    /**
     * Returns the content of the Text object as a simple string, ignoring any
     * non-character elements.
     */
    toString(): string;
    /**
     * Returns the content of the Text object as a sequence of strings,
     * interleaved with non-character elements.
     *
     * For example, the value ['a', 'b', {x: 3}, 'c', 'd'] has spans:
     * => ['ab', {x: 3}, 'cd']
     */
    toSpans(): Value[];
    /**
     * Returns the content of the Text object as a simple string, so that the
     * JSON serialization of an Automerge document represents text nicely.
     */
    toJSON(): string;
    /**
     * Updates the list item at position `index` to a new value `value`.
     */
    set(index: number, value: Value): void;
    /**
     * Inserts new list items `values` starting at position `index`.
     */
    insertAt(index: number, ...values: Value[]): void;
    /**
     * Deletes `numDelete` list items starting at position `index`.
     * if `numDelete` is not given, one item is deleted.
     */
    deleteAt(index: number, numDelete?: number): void;
    map<T>(callback: (e: Value) => T): void;
    lastIndexOf(searchElement: Value, fromIndex?: number): void;
    concat(other: Text): Text;
    every(test: (Value: any) => boolean): boolean;
    filter(test: (Value: any) => boolean): Text;
    find(test: (Value: any) => boolean): Value | undefined;
    findIndex(test: (Value: any) => boolean): number | undefined;
    forEach(f: (Value: any) => undefined): void;
    includes(elem: Value): boolean;
    indexOf(elem: Value): number;
    join(sep?: string): string;
    reduce(f: (previousValue: Value, currentValue: Value, currentIndex: number, array: Value[]) => Value): void;
    reduceRight(f: (previousValue: Value, currentValue: Value, currentIndex: number, array: Value[]) => Value): void;
    slice(start?: number, end?: number): void;
    some(test: (Value: any) => boolean): boolean;
    toLocaleString(): void;
}
